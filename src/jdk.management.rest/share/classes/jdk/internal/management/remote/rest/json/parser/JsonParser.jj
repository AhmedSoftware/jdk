/*
 * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

 /*
  * This is the JavaCC grammar file for a JSON parser. The productions are
  * based on syntax diagrams as specified at json.org
  * Every type of JSON is represent by a JSONElement. JSON Objects are mapped to
  * by LinkedHashMap via JSONObject. JSON Arrays are mapped to ArrayList via JSONArray
  * String, Number, Boolean and null are wrapped into a JSONPrimitive.
  * Control characters inside a string (JSONPrimitive(String)) are not escaped and are passed through
  * to ouput JSON string generated by toJsonString method of JSONElement.
  * Inside a String, only backslash ('\') and double quote ('"') characters
  * are escaped by a backslash, if they are not already escaped.
  * Applications consuming json string generated by JSON* objects must take care
  * to escape control characters within strings by prefixing with a backslash character,
  * if not already escaped.
  */
options {
    STATIC=false;
    ERROR_REPORTING=true;
    JAVA_UNICODE_ESCAPE=true;
    UNICODE_INPUT=true;
    IGNORE_CASE=true;
    CACHE_TOKENS=true;
//    DEBUG_PARSER=true;
//    DEBUG_LOOKAHEAD=true;
//    DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(JSONParser)

package jdk.internal.management.remote.rest.json.parser;

import java.io.StringReader;
import jdk.internal.management.remote.rest.json.*;

public class JSONParser {

    public JSONParser(String input) {
        this(new StringReader(input));
    }

    public JSONElement parse() throws ParseException {
        return jsonValue(); 
    }
}

PARSER_END(JSONParser)

SKIP: {
    " " | "\b" | "\t" | "\n" | "\r" | "\f"
}

TOKEN:{
   <INTEGER_LITERAL : (["-"])? (<DIGITS>)>
|   < FLOATING_POINT_LITERAL:
        <INTEGER_LITERAL> <FRAC>
|       <INTEGER_LITERAL> <EXPONENT>
|       <INTEGER_LITERAL> <FRAC> <EXPONENT>
    >
|   < #FRAC: "." <DIGITS>>
|   < #EXPONENT: ["e","E"] (["+","-"])? <DIGITS> >
|   < #DIGITS : (<DIGIT>)+>
|   < #DIGIT: ["0"-"9"]>
|   <QUOTED_STRING: "\"" ((~["\"","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\""])))* "\"">
|   <BOOL_LITERAL : "true" | "false">
|   <NULL: "null">
}

JSONElement jsonValue() : {
	JSONElement x;
}{
	( x = object()
	| x = list()
	| x = string()
	| x = number()
	| x = boolVal()
	| x = nullVal()
	)
	{ return x; }
}

JSONObject object() : {
	final JSONObject jobject = new JSONObject();
	JSONPrimitive key;
	JSONElement value;
}{
    "{"
        (key = string())
        ":"
        value = jsonValue()
        { jobject.put((String)key.getValue(), value);}
        (
                ","
                (key = string())
                ":"
                value = jsonValue()
                { jobject.put((String)key.getValue(), value);}
        )*
    "}"
    { return jobject; }
}

JSONArray list() : {
    final JSONArray jarray = new JSONArray();
    JSONElement value;
}{
    "["
        value = jsonValue()
        { jarray.add(value);}
        (
            ","
            value = jsonValue()
            { jarray.add(value); }
        )*
    "]"

    { return jarray; }
}

JSONPrimitive nullVal(): {} {
    <NULL>
    { return null; }
}

JSONPrimitive boolVal(): {}
{
    <BOOL_LITERAL>
    {return new JSONPrimitive(Boolean.parseBoolean(token.image));}
}

JSONPrimitive number(): {
    Token t;
}{
    (t = <INTEGER_LITERAL> { return new JSONPrimitive(Long.parseLong(t.image));})
    | (t = <FLOATING_POINT_LITERAL> { return new JSONPrimitive(Double.parseDouble(t.image));})
}

JSONPrimitive string() : {
    Token t;
}{
    (t = <QUOTED_STRING>)
    { return new JSONPrimitive(t.image.substring(1,t.image.length()-1)); }
}
