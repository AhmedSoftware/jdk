/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.internal.reflect;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.lang.classfile.ClassFile;
import java.lang.classfile.TypeKind;
import java.lang.constant.ClassDesc;
import java.lang.constant.ConstantDescs;
import java.lang.constant.DynamicConstantDesc;
import java.lang.constant.MethodTypeDesc;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import jdk.internal.constant.MethodTypeDescImpl;
import jdk.internal.constant.ReferenceClassDescImpl;

/**
 * The private serialization bytecode generator used by {@code sun.misc.ReflectionFactory}.
 */
final class SerializationBytecodeGenerator {
    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();
    @SuppressWarnings("removal")
    private static final ReflectionFactory reflectionFactory = AccessController.doPrivileged((PrivilegedAction<ReflectionFactory>) ReflectionFactory::getReflectionFactory);

    /*
     * The accessors generated by this class are implemented using an anonymous+hidden
     * class to carry the method. Because we are using a non-privileged lookup, we
     * generate unreflected accessor method handles based on setAccessible(true) fields
     * for the (likely) case that we won't have access to a given field. The accessor's
     * type must also be erased to `Object` when non-primitive because we may not have
     * access to the field's type. This is generally not much of a penalty though,
     * because the object-based methods we interact with on `PutField` and `GetField`
     * all work in terms of `Object` anyway.
     */

    // no instances
    private SerializationBytecodeGenerator() {}

    static MethodHandle defaultReadObjectForSerialization(Class<?> cl) {
        List<MethodHandle> setters = new ArrayList<>();
        byte[] bytes = ClassFile.of().build(CD_Generated_readObject, classBuilder -> classBuilder.withMethod("readObject",
            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectInputStream),
            Modifier.STATIC | Modifier.PRIVATE,
            mb -> mb.withCode(cb -> {
                // get our GetField
                cb.aload(1);
                cb.invokevirtual(CD_ObjectInputStream, "readFields", MTD_ObjectInputStream_readFields);
                cb.astore(2);
                // check to see if stream fields are present, and if so, restrict the wire format accordingly
                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);
                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(
                    ObjectStreamField::getName,
                    Function.identity()
                ));
                // iterate the fields of the class
                for (Field field : cl.getDeclaredFields()) {
                    int fieldMods = field.getModifiers();
                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {
                        continue;
                    }
                    String fieldName = field.getName();
                    Class<?> fieldType = field.getType();
                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {
                        // field does not match stream data
                        continue;
                    }

                    // generate setter
                    field.setAccessible(true);
                    int idx = setters.size();
                    MethodHandle mh;
                    try {
                        mh = lookup.unreflectSetter(field);
                        if (fieldType.isPrimitive()) {
                            mh = mh.asType(MethodType.methodType(void.class, Object.class, fieldType));
                        } else {
                            mh = mh.asType(MethodType.methodType(void.class, Object.class, Object.class));
                        }
                        setters.add(mh);
                    } catch (IllegalAccessException e) {
                        throw new InternalError("Error generating accessor for field " + field, e);
                    }
                    cb.ldc(DynamicConstantDesc.ofNamed(
                        ConstantDescs.BSM_CLASS_DATA_AT,
                        ConstantDescs.DEFAULT_NAME,
                        ConstantDescs.CD_MethodHandle,
                        Integer.valueOf(idx)
                    ));
                    // stack: <mh>
                    cb.aload(0); // stack: <mh> this
                    cb.aload(2); // stack: <mh> this GetField
                    cb.ldc(fieldName); // stack: <mh> this GetField <name>

                    ClassDesc fieldDesc = fieldType.describeConstable().orElseThrow(InternalError::new);

                    switch (TypeKind.from(fieldDesc)) {
                        case ByteType -> {
                            cb.iconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_B);
                        }
                        case CharType -> {
                            cb.iconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_C);
                        }
                        case DoubleType -> {
                            cb.dconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_D);
                        }
                        case FloatType -> {
                            cb.fconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_F);
                        }
                        case IntType -> {
                            cb.iconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_I);
                        }
                        case LongType -> {
                            cb.lconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_J);
                        }
                        case ShortType -> {
                            cb.iconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_S);
                        }
                        case BooleanType -> {
                            cb.iconst_0();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_Z);
                        }
                        case ReferenceType -> {
                            cb.aconst_null();
                            cb.invokevirtual(CD_ObjectInputStream_GetField, "get", MTD_ObjectInputStream_GetField_get_L);
                        }
                    }
                    // stack: <mh> this <val>
                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, "invokeExact", mh.type().describeConstable().orElseThrow(InternalError::new));
                }
                cb.return_();
            })
        ));
        try {
            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(setters), true);
            return hcLookup.findStatic(hcLookup.lookupClass(), "readObject", MethodType.methodType(void.class, Object.class, ObjectInputStream.class))
                .asType(MethodType.methodType(void.class, cl, ObjectInputStream.class));
        } catch (IllegalAccessException | NoSuchMethodException e) {
            throw new InternalError("Error in readObject generation", e);
        }
    }

    static MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {
        List<MethodHandle> getters = new ArrayList<>();
        byte[] bytes = ClassFile.of().build(CD_Generated_writeObject, classBuilder -> classBuilder.withMethod("writeObject",
            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectOutputStream),
            Modifier.STATIC | Modifier.PRIVATE,
            mb -> mb.withCode(cb -> {
                // get our PutField
                cb.aload(1);
                cb.invokevirtual(CD_ObjectOutputStream, "putFields", MTD_ObjectOutputStream_putFields);
                cb.astore(2);
                // check to see if stream fields are present, and if so, restrict the wire format accordingly
                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);
                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(
                    ObjectStreamField::getName,
                    Function.identity()
                ));
                // iterate the fields of the class
                for (Field field : cl.getDeclaredFields()) {
                    int fieldMods = field.getModifiers();
                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {
                        continue;
                    }
                    String fieldName = field.getName();
                    Class<?> fieldType = field.getType();
                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {
                        // field does not match stream data
                        continue;
                    }

                    // stack: (empty)
                    cb.aload(2);
                    // stack: PutField
                    cb.ldc(fieldName);
                    // stack: PutField fieldName
                    // generate getter
                    field.setAccessible(true);
                    int idx = getters.size();
                    MethodHandle getter;
                    try {
                        getter = lookup.unreflectGetter(field);
                        if (fieldType.isPrimitive()) {
                            getter = getter.asType(MethodType.methodType(fieldType, Object.class));
                        } else {
                            getter = getter.asType(MethodType.methodType(Object.class, Object.class));
                        }
                        getters.add(getter);
                    } catch (IllegalAccessException e) {
                        throw new InternalError("Error generating accessor for field " + field, e);
                    }
                    cb.ldc(DynamicConstantDesc.ofNamed(
                        ConstantDescs.BSM_CLASS_DATA_AT,
                        ConstantDescs.DEFAULT_NAME,
                        ConstantDescs.CD_MethodHandle,
                        Integer.valueOf(idx)
                    ));
                    // stack: PutField fieldName <mh>
                    cb.aload(0);
                    // stack: PutField fieldName <mh> this
                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, "invokeExact", getter.type().describeConstable().orElseThrow(InternalError::new));
                    // stack: PutField fieldName <val>
                    switch (TypeKind.from(fieldType)) {
                        case ByteType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_B);
                        case CharType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_C);
                        case DoubleType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_D);
                        case FloatType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_F);
                        case IntType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_I);
                        case LongType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_J);
                        case ShortType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_S);
                        case BooleanType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_Z);
                        case ReferenceType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, "put", MTD_ObjectOutputStream_PutField_put_L);
                    }
                    // stack: (empty)
                }
                // commit fields to stream
                cb.aload(1);
                cb.invokevirtual(CD_ObjectOutputStream, "writeFields", ConstantDescs.MTD_void);
                cb.return_();
            })
        ));
        try {
            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(getters), true);
            return hcLookup.findStatic(hcLookup.lookupClass(), "writeObject", MethodType.methodType(void.class, Object.class, ObjectOutputStream.class))
                .asType(MethodType.methodType(void.class, cl, ObjectOutputStream.class));
        } catch (IllegalAccessException | NoSuchMethodException e) {
            throw new InternalError("Error in writeObject generation", e);
        }
    }

    private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated("Ljava/io/ObjectInputStream;");
    private static final ClassDesc CD_ObjectInputStream_GetField = ReferenceClassDescImpl.ofValidated("Ljava/io/ObjectInputStream$GetField;");

    private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated("Ljava/io/ObjectOutputStream;");
    private static final ClassDesc CD_ObjectOutputStream_PutField = ReferenceClassDescImpl.ofValidated("Ljava/io/ObjectOutputStream$PutField;");

    private static final ClassDesc CD_Generated_writeObject = ReferenceClassDescImpl.ofValidated("Ljdk/internal/reflect/Generated$$writeObject;");
    private static final ClassDesc CD_Generated_readObject = ReferenceClassDescImpl.ofValidated("Ljdk/internal/reflect/Generated$$readObject;");

    private static final MethodTypeDesc MTD_ObjectInputStream_readFields = MethodTypeDescImpl.ofValidated(CD_ObjectInputStream_GetField);

    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_byte, ConstantDescs.CD_String, ConstantDescs.CD_byte);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_char, ConstantDescs.CD_String, ConstantDescs.CD_char);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_double, ConstantDescs.CD_String, ConstantDescs.CD_double);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_float, ConstantDescs.CD_String, ConstantDescs.CD_float);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_String, ConstantDescs.CD_int);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_long, ConstantDescs.CD_String, ConstantDescs.CD_long);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_Object, ConstantDescs.CD_String, ConstantDescs.CD_Object);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_short, ConstantDescs.CD_String, ConstantDescs.CD_short);
    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_boolean, ConstantDescs.CD_String, ConstantDescs.CD_boolean);

    private static final MethodTypeDesc MTD_ObjectOutputStream_putFields = MethodTypeDescImpl.ofValidated(CD_ObjectOutputStream_PutField);

    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_byte);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_char);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_double);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_float);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_int);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_long);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_Object);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_short);
    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_boolean);
}
